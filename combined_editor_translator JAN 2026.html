<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Transcript Text Editor - Unit Tracker</title>
  <style>
    /* Theme variables */
    :root {
      --primary-bg: #fff;
      --primary-text: #333;
      --secondary-bg: #f5f5f5;
      --button-bg: #444;
      --button-hover: #666;
      --button-text: #fff;
      --status-bg: #222;
      --status-text: #fff;
      --notification-bg: rgba(0,0,0,0.8);
      --format-btn-bg: #ddd;
      --format-btn-text: #333;
      --progress-bar-bg: #0066ff;
      --progress-marker: #ffffff;
      --jump-btn-bg: #5a5a5a;
      --jump-btn-hover: #777777;
      --jump-btn-active: #0099ff;
      --analyze-btn-bg: #0099ff;
      --analyze-btn-hover: #007acc;
    }

    .dark-mode {
      --primary-bg: #222;
      --primary-text: #eee;
      --secondary-bg: #444;
      --button-bg: #555;
      --button-hover: #777;
      --format-btn-bg: #555;
      --format-btn-text: #eee;
      --jump-btn-bg: #333;
      --jump-btn-hover: #555;
      --analyze-btn-bg: #007acc;
      --analyze-btn-hover: #005a99;
    }

    /* Progress bar at top of screen */
    #top-progress-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background-color: var(--secondary-bg);
      z-index: 1000;
      overflow: hidden;
      display: flex;
    }

    .unit-progress-bar {
      height: 100%;
      width: 0;
      background-color: transparent;
      position: relative;
      overflow: hidden;
    }

    .unit-progress-bar-inner {
      height: 100%;
      width: 0%;
      background-color: var(--progress-bar-bg);
      transition: width 0.3s ease;
      position: absolute;
      top: 0;
      left: 0;
    }

    .progress-markers {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      pointer-events: none;
    }

    .progress-marker {
      flex: 1;
      height: 100%;
      border-right: 2px solid var(--progress-marker);
      box-sizing: border-box;
    }

    .progress-marker:last-child {
      border-right: none;
    }

    /* Base styles */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      color: var(--primary-text);
      background-color: var(--primary-bg);
      transition: background-color 0.3s, color 0.3s;
    }

    /* Progress zones */
    .progress-zones-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
    }

    .progress-zone {
      width: 100%;
      height: 10%;
      background-color: transparent;
      transition: background-color 0.5s ease;
    }

    .progress-zone.active {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .dark-mode .progress-zone.active {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* Layout */
    #status-bar {
      position: sticky;
      top: 0;
      background: var(--status-bg);
      color: var(--status-text);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 100;
    }

    #main-status-row {
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    #unit-jump-row {
      padding: 0 1rem 0.3rem 1rem;
      display: flex;
      gap: 0.15rem;
      flex-wrap: wrap;
      max-height: 30px;
      overflow-y: auto;
    }

    .unit-group {
        display: flex;
        gap: 0.15rem;
    }

    /* Jump buttons style */
    .jump-btn {
      background-color: var(--jump-btn-bg);
      color: var(--button-text);
      border: 1px solid var(--jump-btn-bg);
      padding: 0.2rem 0.5rem;
      font-size: 0.7rem;
      line-height: 1.2;
      transition: background-color 0.2s, border-color 0.2s;
      white-space: nowrap;
    }

    .jump-btn.copy-btn {
        padding: 0.2rem 0.35rem;
        font-size: 0.65rem;
    }

    .jump-btn:hover {
      background-color: var(--jump-btn-hover);
    }

    .jump-btn.active {
      background-color: var(--jump-btn-active);
      border-color: var(--jump-btn-active);
    }

    #editor-container {
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      overflow: hidden;
    }

    #editor {
      padding: 1.5rem;
      border: none;
      outline: none;
      overflow-y: auto;
      line-height: 1.5;
      max-width: 800px;
      width: 100%;
      box-sizing: border-box;
      background-color: transparent;
      color: var(--primary-text);
      height: 100%;
      position: relative;
      z-index: 10;
      font-size: 18pt;
    }

    /* Controls */
    .status-left {
      display: flex;
      flex-direction: row;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.85rem;
    }

    .controls {
      display: flex;
      gap: 0.3rem;
      align-items: center;
    }

    button {
      cursor: pointer;
      border-radius: 3px;
      border: none;
      transition: background-color 0.2s;
    }

    #save-btn, #undo-btn {
      background: var(--button-bg);
      color: var(--button-text);
      padding: 0.35rem 0.7rem;
      font-size: 0.75rem;
    }

    #analyze-btn {
      background: var(--analyze-btn-bg);
      color: var(--button-text);
      padding: 0.35rem 0.7rem;
      font-size: 0.75rem;
    }

    #save-btn:hover, #undo-btn:hover {
      background: var(--button-hover);
    }

    #analyze-btn:hover {
      background: var(--analyze-btn-hover);
    }

    #theme-toggle {
      background: none;
      color: var(--status-text);
      padding: 0.2rem;
      font-size: 0.9rem;
    }

    /* Pomodoro Indicator Styles */
    #pomodoro-indicators {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 3px;
        padding-left: 0.3rem;
        font-size: 0.8rem;
    }
    .pomodoro-square {
        width: 16px;
        height: 16px;
        border: 1px solid var(--button-bg);
        background-color: transparent;
        position: relative;
        overflow: hidden;
        display: inline-block;
        box-sizing: border-box;
    }
    .pomodoro-square-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background-color: #4CAF50;
        transition: width 0.3s ease;
    }
    .pomodoro-square.completed .pomodoro-square-fill {
        width: 100%;
    }
    .pomodoro-square.current {
        border-color: var(--primary-text);
        border-width: 1.5px;
    }
    .pomodoro-square.current .pomodoro-square-fill {
        background-color: #FFC107;
    }

    /* M/R Clickable Prefix */
    .mr-swap-link {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-style: dotted;
        color: inherit;
        user-select: none;
    }

    .mr-swap-link:hover {
        text-decoration-style: solid;
        opacity: 0.7;
    }

    /* Notification */
    #notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--notification-bg);
      color: var(--status-text);
      padding: 10px 15px;
      border-radius: 4px;
      display: none;
      z-index: 2000;
      transition: opacity 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    #file-id-input, #set-file-id-btn, #file-id-display {
        display: none !important;
    }

    @media (max-width: 600px) {
      #main-status-row {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }
      .controls {
        width: 100%;
        justify-content: flex-end;
      }
      #editor {
        padding: 1rem;
      }
      #pomodoro-indicators {
        padding-left: 0;
        margin-top: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <div id="top-progress-container"></div>
  <div id="status-bar">
    <div id="main-status-row">
      <div class="status-left">
        <span id="progress">Unit 1/3 ‚Ä¢ 0%</span>
        <span id="eta" style="font-size: 0.8rem;">0w ‚Ä¢ 0min</span>
        <div id="pomodoro-indicators">Pomodoros: 0</div>
      </div>
      <div class="controls">
        <button id="theme-toggle" aria-label="Toggle dark mode" title="Dark mode">üåô</button>
        <button id="analyze-btn" aria-label="Analyze and Format" title="Analyze & Format">Format</button>
        <button id="undo-btn" aria-label="Undo last action" title="Undo">‚Ü§</button>
        <button id="save-btn" aria-label="Save content" title="Save (hold 2s to clear all data)">üíæ</button>
      </div>
    </div>
    <div id="unit-jump-row"></div>
  </div>

  <div id="editor-container">
    <div class="progress-zones-container" id="progress-zones"></div>
    <div id="editor" contenteditable="true" aria-label="Text editor with auto-formatting" role="textbox">
      <p>Unit 1: Edit your pre-loaded content here.</p>
      <p>M: This is a marked paragraph that should be bold.</p>
      <p>R: This should not be bold.</p>
      <p>***</p>
      <p>Unit 2: This is the start of the second unit, separated by three asterisks.</p>
      <p>M: How far are we into this project?</p>
      <p>R: We're making good progress now.</p>
      <p>***</p>
      <p>Unit 3: This is the final unit.</p>
      <p>Final paragraph...</p>
    </div>
  </div>

  <div id="notification" role="status" aria-live="polite"></div>

  <script>
    // DOM Elements
    const editor = document.getElementById('editor');
    const etaDisplay = document.getElementById('eta');
    const progressDisplay = document.getElementById('progress');
    const saveBtn = document.getElementById('save-btn');
    const notification = document.getElementById('notification');
    const themeToggle = document.getElementById('theme-toggle');
    const progressZones = document.getElementById('progress-zones');
    const topProgressContainer = document.getElementById('top-progress-container');
    const unitJumpRow = document.getElementById('unit-jump-row');
    const undoBtn = document.getElementById('undo-btn');
    const pomodoroIndicators = document.getElementById('pomodoro-indicators');
    const analyzeBtn = document.getElementById('analyze-btn');

    // Double-init guard
    let initialized = false;

    // Progress cache - avoids redundant recomputation within a single event
    let _frameCounter = 0;
    let _progressCache = null;
    let _progressCacheFrame = -1;

    // State
    const state = {
      lastScrollTime: Date.now(),
      wordCount: 0,
      isDarkMode: false,
      isDirty: false,
      scrollData: [],
      eta: 120,
      minEta: 120,
      undoHistory: [],
      isUndoing: false,
      isPasting: false,
      notificationTimer: null,
      notificationFadeTimer: null,
      saveHoldTimer: null,
      timers: {
        format: null,
        undo: null,
        unitCalc: null,
        wordCount: null
      },
      units: [],
      totalScrollableHeight: 0
    };

    // Config
    const config = {
      undoLimit: 50,
      undoMaxBytes: 2 * 1024 * 1024,
      formatDelay: 300,
      undoDelay: 500,
      unitCalcDelay: 1000,
      wordCountDelay: 500,
      scrollSamplesLimit: 30,
      notificationDuration: 2000,
      statusInterval: 5000,
      autoSaveInterval: 60000,
      largePasteThreshold: 5000
    };

    // Initialize
    function init() {
      if (initialized) return;
      initialized = true;

      loadContent();
      loadUndoHistory();
      setupEvents();
      countWords();
      loadTheme();
      createProgressMarkers();

      requestAnimationFrame(() => {
        manualAnalyzeAndFormat();

        setTimeout(() => {
          restoreScroll();
          saveUndo();
        }, 100);
      });

      setInterval(updateStatus, config.statusInterval);

      // Auto-save every 60s if content changed
      setInterval(() => {
        if (state.isDirty) {
          saveToStorage();
          state.isDirty = false;
        }
      }, config.autoSaveInterval);
    }

    function createProgressMarkers() {
      progressZones.innerHTML = '';

      for (let i = 1; i <= 10; i++) {
        const zone = document.createElement('div');
        zone.className = 'progress-zone';
        zone.dataset.progress = i / 10;
        progressZones.appendChild(zone);
      }
    }

    function updateProgressMarkers(currentProgress) {
      const zones = progressZones.querySelectorAll('.progress-zone');

      zones.forEach(zone => {
        const zoneProgress = parseFloat(zone.dataset.progress);
        if (currentProgress >= zoneProgress) {
          zone.classList.add('active');
        } else {
          zone.classList.remove('active');
        }
      });
    }

    // Event setup
    function setupEvents() {
      editor.addEventListener('scroll', onScroll);
      editor.addEventListener('input', onInput);
      editor.addEventListener('paste', onPaste);

      saveBtn.addEventListener('click', onSave);
      themeToggle.addEventListener('click', toggleTheme);
      undoBtn.addEventListener('click', performUndo);
      analyzeBtn.addEventListener('click', manualAnalyzeAndFormat);

      document.addEventListener('keydown', handleKeys);

      window.addEventListener('beforeunload', saveState);

      // Long-press save button (2s) to clear all storage
      const startHold = (e) => {
        // Prevent context menu on long-press (mobile)
        state.saveHoldTimer = setTimeout(() => {
          state.saveHoldTimer = null;
          const confirmed = confirm('Clear ALL saved data? This cannot be undone.');
          if (confirmed) {
            localStorage.clear();
            state.undoHistory = [];
            editor.innerHTML = '<p>Cleared. Ready for new content.</p>';
            state.wordCount = 0;
            state.isDirty = false;
            showNotification('All data cleared!', 2000);
            setTimeout(() => location.reload(), 1000);
          }
        }, 2000);
      };
      const cancelHold = () => {
        if (state.saveHoldTimer) {
          clearTimeout(state.saveHoldTimer);
          state.saveHoldTimer = null;
        }
      };
      saveBtn.addEventListener('mousedown', startHold);
      saveBtn.addEventListener('mouseup', cancelHold);
      saveBtn.addEventListener('mouseleave', cancelHold);
      saveBtn.addEventListener('touchstart', startHold);
      saveBtn.addEventListener('touchend', cancelHold);
      saveBtn.addEventListener('touchcancel', cancelHold);
    }

    // Keyboard shortcuts
    function handleKeys(e) {
      if (e.ctrlKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            performUndo();
            break;
          case 's':
            e.preventDefault();
            onSave();
            break;
        }
      }
    }

    // Handle scroll
    function onScroll() {
      _frameCounter++;
      state.lastScrollTime = Date.now();

      const progress = getProgress();
      if (state.scrollData.length > 0) {
        const lastProgress = state.scrollData[state.scrollData.length - 1].progress;
        if (lastProgress - progress > 0.2) {
          state.scrollData = [];
          if (state.eta > 0) {
            state.minEta = Math.round(state.eta * 1.1);
          }
        }
      }

      recordProgress();
      updateStatus();
    }

    // Handle input
    function onInput() {
      if (state.isPasting) return;

      _frameCounter++;
      state.isDirty = true;

      scheduleWordCount();
      recordProgress();

      if (!state.isUndoing) {
        clearTimeout(state.timers.undo);
        state.timers.undo = setTimeout(saveUndo, config.undoDelay);
      }

      updateStatus();
    }

    // Debounced word count
    function scheduleWordCount() {
      clearTimeout(state.timers.wordCount);
      state.timers.wordCount = setTimeout(countWords, config.wordCountDelay);
    }

    // Handle paste - optimized for large text
    function onPaste(e) {
      e.preventDefault();
      const text = (e.clipboardData || window.clipboardData).getData('text/plain');
      if (!text) return;

      if (text.length > config.largePasteThreshold) {
        state.isPasting = true;
        state.isDirty = true;
        showNotification('Pasting large text...', 1000);

        // Build DOM fragment off-screen for performance
        const lines = text.split('\n');
        const fragment = document.createDocumentFragment();

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i].trim();
          if (line === '') continue;
          const p = document.createElement('p');
          p.textContent = line;
          fragment.appendChild(p);
        }

        // Find insertion point as a direct child of editor
        const sel = window.getSelection();
        let insertBefore = null;

        if (sel.rangeCount) {
          const range = sel.getRangeAt(0);
          range.deleteContents();

          // Walk up to find the direct child of editor
          let anchor = range.startContainer;
          while (anchor && anchor !== editor && anchor.parentNode !== editor) {
            anchor = anchor.parentNode;
          }

          if (anchor && anchor !== editor) {
            insertBefore = anchor.nextSibling;
          }
        }

        // Insert all <p> elements as direct children of editor (no nesting)
        if (insertBefore) {
          editor.insertBefore(fragment, insertBefore);
        } else {
          editor.appendChild(fragment);
        }

        // Move cursor to end of pasted content
        const lastPasted = insertBefore ? insertBefore.previousSibling : editor.lastChild;
        if (lastPasted && sel) {
          const newRange = document.createRange();
          newRange.selectNodeContents(lastPasted);
          newRange.collapse(false);
          sel.removeAllRanges();
          sel.addRange(newRange);
        }

        // Defer expensive operations
        requestAnimationFrame(() => {
          state.isPasting = false;
          _frameCounter++;
          countWords();
          clearTimeout(state.timers.format);
          state.timers.format = setTimeout(() => {
            manualAnalyzeAndFormat();
            saveUndo();
            showNotification('Large paste formatted.', 1500);
          }, 300);
        });
      } else {
        // Small paste: use execCommand for proper undo integration
        state.isDirty = true;
        document.execCommand('insertText', false, text);
      }
    }

    // Save to undo history
    function saveUndo() {
      const currentContent = editor.innerHTML;
      const lastContent = state.undoHistory.length > 0 ? state.undoHistory[state.undoHistory.length - 1].content : null;

      if (currentContent !== lastContent) {
        state.undoHistory.push({ content: currentContent, timestamp: Date.now() });
      }

      // Trim by count
      if (state.undoHistory.length > config.undoLimit) {
        state.undoHistory.shift();
      }

      // Trim by byte size
      trimUndoBySize();

      saveUndoHistory();
    }

    // Cap undo history to stay within byte budget
    function trimUndoBySize() {
      let totalSize = 0;
      for (let i = state.undoHistory.length - 1; i >= 0; i--) {
        totalSize += state.undoHistory[i].content.length;
        if (totalSize > config.undoMaxBytes) {
          state.undoHistory = state.undoHistory.slice(i + 1);
          return;
        }
      }
    }

    // Perform undo
    function performUndo() {
      if (state.undoHistory.length <= 1) {
          showNotification('Nothing left to undo.', 1500);
          return;
      }

      state.undoHistory.pop();
      const prevState = state.undoHistory[state.undoHistory.length - 1];

      state.isUndoing = true;
      editor.innerHTML = prevState.content;
      state.isDirty = true;
      _frameCounter++;

      saveUndoHistory();

      setTimeout(() => {
        state.isUndoing = false;
        manualAnalyzeAndFormat();
      }, 10);

      showNotification('Undo successful (Ctrl+Z)', 1500);
    }

    // Save content
    function onSave() {
      // Temporarily disable input events during formatting to prevent re-dirtying
      const originalIsPasting = state.isPasting;
      state.isPasting = true;

      try {
        manualAnalyzeAndFormat();
      } catch (e) {
        console.error('Format error during save:', e);
        showNotification('Format failed, saving anyway...', 2000);
      }

      state.isPasting = originalIsPasting;

      if (saveToStorage()) {
        state.isDirty = false;
        saveBtn.textContent = "SAVED!";
        showNotification('Content saved successfully');
        setTimeout(() => { saveBtn.textContent = "üíæ"; }, 1500);
      }
    }

    function getProgress() {
      const { totalProgress } = getCurrentUnitProgress();
      return totalProgress;
    }

    function recordProgress() {
      const progress = getProgress();
      if (isNaN(progress) || progress < 0 || progress > 1) return;

      const now = Date.now();

      if (state.scrollData.length > 0) {
        const last = state.scrollData[state.scrollData.length - 1];
        if (progress === last.progress && now - last.time < 30000) {
          return;
        }
      }

      state.scrollData.push({ time: now, progress });

      if (state.scrollData.length > config.scrollSamplesLimit) {
        state.scrollData.shift();
      }
    }

    function countWords() {
      const text = editor.innerText || '';
      state.wordCount = text.split(/\s+/).filter(Boolean).length;
    }

    function updatePomodoroIndicators(totalPomodoros, totalProgress) {
        if (!pomodoroIndicators) return;

        pomodoroIndicators.innerHTML = '';

        if (totalPomodoros === 0) {
            pomodoroIndicators.textContent = 'Pomodoros: 0';
            return;
        }

        const label = document.createElement('span');
        label.textContent = 'Pomodoros: ';
        label.style.marginRight = '2px';
        pomodoroIndicators.appendChild(label);

        const maxSquares = 10;
        const displayTotal = Math.min(totalPomodoros, maxSquares);

        const exactProgress = totalProgress * totalPomodoros;
        const currentPomodoroIndex = Math.floor(exactProgress);
        const currentPomodoroProgress = exactProgress - currentPomodoroIndex;

        for (let i = 0; i < displayTotal; i++) {
            const square = document.createElement('div');
            square.className = 'pomodoro-square';

            const fill = document.createElement('div');
            fill.className = 'pomodoro-square-fill';

            if (i < currentPomodoroIndex) {
                square.classList.add('completed');
            } else if (i === currentPomodoroIndex) {
                square.classList.add('current');
                fill.style.width = `${Math.round(currentPomodoroProgress * 100)}%`;
            }

            square.appendChild(fill);
            pomodoroIndicators.appendChild(square);
        }

        if (totalPomodoros > maxSquares) {
             const ellipsis = document.createElement('span');
             ellipsis.style.fontSize = '12px';
             ellipsis.style.paddingLeft = '5px';
             ellipsis.style.color = 'var(--status-text)';
             ellipsis.textContent = ` ... (+${totalPomodoros - maxSquares})`;
             pomodoroIndicators.appendChild(ellipsis);
        }
    }

    // Single-pass format: combines formatMarkedText + addMRSwapButtons + removeEmptyLines
    function formatAndClean() {
        // Remove existing swap links first (single querySelectorAll)
        const existingLinks = editor.querySelectorAll('.mr-swap-link');
        existingLinks.forEach(link => {
            const textNode = document.createTextNode(link.textContent);
            link.parentNode.replaceChild(textNode, link);
        });

        // Single pass over all <p> elements
        const blocks = editor.querySelectorAll('p');
        const toRemove = [];

        blocks.forEach(block => {
            const text = (block.textContent || '').trim();

            // Remove empty lines
            if (text === '' || text === '<br>') {
                toRemove.push(block);
                return;
            }

            if (text.startsWith("M:")) {
                // Bold formatting for M: lines
                const strong = block.querySelector('strong');
                if (!strong || strong.textContent.trim() !== text) {
                    const existingStrongs = block.querySelectorAll('strong');
                    existingStrongs.forEach(s => {
                        while (s.firstChild) block.insertBefore(s.firstChild, s);
                        s.remove();
                    });
                    block.innerHTML = `<strong>${block.innerHTML}</strong>`;
                }
                addSwapLinkToBlock(block);
            }
            else if (text.startsWith("R:")) {
                // Remove bold from R: lines
                const strongElements = block.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    while (strong.firstChild) block.insertBefore(strong.firstChild, strong);
                    strong.remove();
                });
                addSwapLinkToBlock(block);
            }
            else if (/^\*{3,}$/.test(text)) {
                // Remove bold from separator lines
                const strongElements = block.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    while (strong.firstChild) block.insertBefore(strong.firstChild, strong);
                    strong.remove();
                });
            }
        });

        toRemove.forEach(block => block.remove());
    }

    // Add a clickable M:/R: swap link to a single block
    function addSwapLinkToBlock(block) {
        const walker = document.createTreeWalker(block, NodeFilter.SHOW_TEXT, null, false);

        let textNode;
        while (textNode = walker.nextNode()) {
            const nodeText = textNode.nodeValue || '';
            const trimmedText = nodeText.trim();

            if (trimmedText.startsWith('M:') || trimmedText.startsWith('R:')) {
                const prefix = trimmedText.substring(0, 2);
                const prefixIndex = nodeText.indexOf(prefix);

                if (prefixIndex !== -1) {
                    const beforePrefix = nodeText.substring(0, prefixIndex);
                    const afterPrefix = nodeText.substring(prefixIndex + 2);

                    const span = document.createElement('span');
                    span.className = 'mr-swap-link';
                    span.textContent = prefix;
                    span.title = 'Click to swap M: ‚Üî R: from here down in this unit';
                    span.contentEditable = false;

                    span.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        swapMRInUnit(block);
                    });

                    const parent = textNode.parentNode;
                    parent.insertBefore(document.createTextNode(beforePrefix), textNode);
                    parent.insertBefore(span, textNode);
                    parent.insertBefore(document.createTextNode(afterPrefix), textNode);
                    parent.removeChild(textNode);

                    break;
                }
            }
        }
    }

    function manualAnalyzeAndFormat() {
        formatAndClean();
        countWords();
        calculateUnitsAndScrollPositions();
    }

    function updateStatus() {
      _frameCounter++;
      recordProgress();

      const {
        currentUnitIndex, unitProgress, totalProgress, totalUnits
      } = getCurrentUnitProgress();

      updateProgressBars(currentUnitIndex, unitProgress);
      updateUnitJumpButtons(currentUnitIndex);

      if (!isNaN(totalProgress)) {
        const unitPercent = Math.min(100, Math.max(0, Math.round(unitProgress * 100)));

        progressDisplay.textContent = `Unit ${currentUnitIndex + 1}/${totalUnits} ‚Ä¢ ${unitPercent}%`;

        updateProgressMarkers(totalProgress);
      }

      const WORDS_PER_45_MIN = 6000;
      const MINUTES_PER_BENCHMARK = 45;
      const TARGET_POMODORO_MINUTES = 25;

      const totalExpectedMins = Math.round((state.wordCount / WORDS_PER_45_MIN) * MINUTES_PER_BENCHMARK);

      // Calculate number of pomodoros, then divide total time equally
      const totalPomodoros = Math.ceil(totalExpectedMins / TARGET_POMODORO_MINUTES);
      const equalPomodoroLength = totalPomodoros > 0 ? totalExpectedMins / totalPomodoros : 0;

      const remainingProgress = Math.max(0, 1 - totalProgress);
      const remainingMins = Math.round(totalExpectedMins * remainingProgress);

      // Calculate ETA to end of current pomodoro
      const currentPomodoroIndex = Math.floor(totalProgress * totalPomodoros);
      const currentPomodoroEnd = (currentPomodoroIndex + 1) * equalPomodoroLength;
      const elapsedMins = totalExpectedMins * totalProgress;
      const minsToCurrentPomodoroEnd = Math.max(0, Math.round(currentPomodoroEnd - elapsedMins));

      // Display: current pomodoro ETA | total file ETA
      etaDisplay.textContent = `${state.wordCount}w ‚Ä¢ ‚è±${minsToCurrentPomodoroEnd}m | üìÑ${remainingMins}m`;

      updatePomodoroIndicators(totalPomodoros, totalProgress);
    }

    function swapMRInUnit(startingBlock) {
        let currentUnit = null;
        for (let i = 0; i < state.units.length; i++) {
            const unit = state.units[i];
            if (unit.children && Array.from(unit.children).includes(startingBlock)) {
                currentUnit = unit;
                break;
            }
        }

        if (!currentUnit) return;

        const unitChildren = Array.from(currentUnit.children);
        const startIndex = unitChildren.indexOf(startingBlock);

        if (startIndex === -1) return;

        for (let i = startIndex; i < unitChildren.length; i++) {
            const block = unitChildren[i];
            const text = (block.textContent || '').trim();

            if (text.startsWith("M:")) {
                replacePrefix(block, "M:", "R:");
                const strongElements = block.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    while (strong.firstChild) {
                        block.insertBefore(strong.firstChild, strong);
                    }
                    strong.remove();
                });
            } else if (text.startsWith("R:")) {
                replacePrefix(block, "R:", "M:");
                const existingStrongs = block.querySelectorAll('strong');
                existingStrongs.forEach(s => {
                    while (s.firstChild) {
                        block.insertBefore(s.firstChild, s);
                    }
                    s.remove();
                });
                const content = block.innerHTML;
                block.innerHTML = `<strong>${content}</strong>`;
            }
        }

        formatAndClean();
        saveState();
        showNotification('M: and R: swapped from this point onwards in unit', 1500);
    }

    function replacePrefix(block, oldPrefix, newPrefix) {
        const walker = document.createTreeWalker(
            block,
            NodeFilter.SHOW_ALL,
            null,
            false
        );

        let node;
        while (node = walker.nextNode()) {
            if (node.nodeType === Node.TEXT_NODE) {
                const nodeText = node.nodeValue || '';
                if (nodeText.includes(oldPrefix)) {
                    node.nodeValue = nodeText.replace(oldPrefix, newPrefix);
                    break;
                }
            } else if (node.nodeType === Node.ELEMENT_NODE && node.classList && node.classList.contains('mr-swap-link')) {
                if (node.textContent === oldPrefix) {
                    node.textContent = newPrefix;
                    break;
                }
            }
        }
    }

    function calculateUnitsAndScrollPositions() {
        state.units = [];
        const children = Array.from(editor.children);

        if (children.length === 0) {
            state.totalScrollableHeight = 0;
            updateProgressContainerUI();
            createUnitJumpButtons();
            return;
        }

        let currentUnit = { startScroll: 0, children: [] };

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const trimmedText = (child.textContent || '').trim();
            const isSeparator = /^\*{3,}$/.test(trimmedText);

            if (isSeparator) {
                if (currentUnit.children.length > 0) {
                    const lastChild = currentUnit.children[currentUnit.children.length - 1];
                    currentUnit.endScroll = lastChild.offsetTop + lastChild.offsetHeight;
                    currentUnit.height = currentUnit.endScroll - currentUnit.startScroll;
                    state.units.push(currentUnit);
                }

                currentUnit = {
                    startScroll: child.offsetTop + child.offsetHeight,
                    children: []
                };
            } else {
                currentUnit.children.push(child);
            }
        }

        if (currentUnit.children.length > 0) {
            const lastChild = currentUnit.children[currentUnit.children.length - 1];
            currentUnit.endScroll = lastChild.offsetTop + lastChild.offsetHeight;
            currentUnit.height = currentUnit.endScroll - currentUnit.startScroll;
            state.units.push(currentUnit);
        }

        if (state.units.length === 0 && children.length > 0) {
             const lastChild = children[children.length - 1];
             state.units.push({
                startScroll: 0,
                endScroll: lastChild.offsetTop + lastChild.offsetHeight,
                height: lastChild.offsetTop + lastChild.offsetHeight,
                children: children
            });
        }

        state.totalScrollableHeight = editor.scrollHeight - editor.clientHeight;

        updateProgressContainerUI();
        createUnitJumpButtons();

        _frameCounter++;
        updateStatus();
    }

    function updateProgressContainerUI() {
        topProgressContainer.innerHTML = '';

        const totalUnits = state.units.length;
        if (totalUnits === 0) return;

        const unitWidth = 100 / totalUnits;

        state.units.forEach((unit, index) => {
            const unitBar = document.createElement('div');
            unitBar.className = 'unit-progress-bar';
            unitBar.style.width = `${unitWidth}%`;
            unitBar.dataset.unitIndex = index;

            const unitBarInner = document.createElement('div');
            unitBarInner.className = 'unit-progress-bar-inner';
            unitBar.appendChild(unitBarInner);

            const markers = document.createElement('div');
            markers.className = 'progress-markers';
            for (let i = 0; i < 10; i++) {
                const marker = document.createElement('div');
                marker.className = 'progress-marker';
                markers.appendChild(marker);
            }
            unitBar.appendChild(markers);

            topProgressContainer.appendChild(unitBar);
        });
    }

    function createUnitJumpButtons() {
        unitJumpRow.innerHTML = '';
        state.units.forEach((unit, index) => {
            const unitGroup = document.createElement('div');
            unitGroup.className = 'unit-group';

            const jumpButton = document.createElement('button');
            jumpButton.className = 'jump-btn';

            let buttonLabel = `Unit ${index + 1}`;
            if (unit.children && unit.children.length > 0) {
                const firstElement = unit.children[0];
                const firstLineText = firstElement.innerText || firstElement.textContent || '';
                const firstLine = firstLineText.split('\n')[0].trim();
                if (firstLine.length > 0) {
                    buttonLabel = firstLine.substring(0, 5);
                }
            }

            jumpButton.textContent = buttonLabel;
            jumpButton.dataset.unitIndex = index;
            jumpButton.dataset.scrollPosition = unit.startScroll;

            jumpButton.addEventListener('click', (e) => {
                const scrollPos = parseInt(e.target.dataset.scrollPosition);
                editor.scrollTop = scrollPos;
            });

            const copyButton = document.createElement('button');
            copyButton.className = 'jump-btn copy-btn';
            copyButton.textContent = 'üìã';
            copyButton.title = `Copy Unit ${index + 1} Text`;
            copyButton.dataset.unitIndex = index;

            copyButton.addEventListener('click', (e) => {
                const unitIndexToCopy = parseInt(e.currentTarget.dataset.unitIndex);
                copyUnitText(unitIndexToCopy);
            });

            unitGroup.appendChild(jumpButton);
            unitGroup.appendChild(copyButton);
            unitJumpRow.appendChild(unitGroup);
        });
    }

    function copyUnitText(unitIndex) {
        const unit = state.units[unitIndex];
        if (!unit || unit.children.length === 0) {
            showNotification(`Unit ${unitIndex + 1} is empty.`, 2000);
            return;
        }

        let unitText = '';
        unit.children.forEach(child => {
            const clone = child.cloneNode(true);
            const swapLinks = clone.querySelectorAll('.mr-swap-link');
            swapLinks.forEach(link => link.remove());
            unitText += clone.innerText + '\n\n';
        });

        unitText = unitText.trim();

        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(unitText)
                .then(() => {
                    showNotification(`Unit ${unitIndex + 1} copied!`, 2000);
                })
                .catch(() => {
                    fallbackCopy(unitText, unitIndex);
                });
        } else {
            fallbackCopy(unitText, unitIndex);
        }
    }

    function fallbackCopy(text, unitIndex) {
        const tempTextarea = document.createElement('textarea');
        tempTextarea.style.position = 'fixed';
        tempTextarea.style.opacity = '0';
        tempTextarea.value = text;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        try {
            document.execCommand('copy');
            showNotification(`Unit ${unitIndex + 1} copied!`, 2000);
        } catch (err) {
            showNotification('Failed to copy text.', 3000);
        }
        document.body.removeChild(tempTextarea);
    }

    function updateUnitJumpButtons(currentUnitIndex) {
        const buttons = unitJumpRow.querySelectorAll('.jump-btn:not(.copy-btn)');
        buttons.forEach((button, index) => {
            if (index === currentUnitIndex) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }

    // Cached per-frame to avoid redundant recomputation
    function getCurrentUnitProgress() {
        if (_progressCache && _progressCacheFrame === _frameCounter) {
            return _progressCache;
        }

        const scroll = editor.scrollTop;
        const totalUnits = state.units.length;

        let currentUnitIndex = 0;
        let unitProgress = 0;
        let totalProgress = 0;

        if (totalUnits === 0) {
            const maxScroll = editor.scrollHeight - editor.clientHeight;
            if (maxScroll <= 0) {
                totalProgress = 0;
            } else {
                totalProgress = Math.min(1, scroll / maxScroll);
            }
            const result = { currentUnitIndex: 0, unitProgress: totalProgress, unitWeight: 1, totalProgress: totalProgress, totalUnits: 1 };
            _progressCache = result;
            _progressCacheFrame = _frameCounter;
            return result;
        }

        if (state.totalScrollableHeight <= 0) {
            const result = { currentUnitIndex: 0, unitProgress: 0, unitWeight: 0, totalProgress: 0, totalUnits };
            _progressCache = result;
            _progressCacheFrame = _frameCounter;
            return result;
        }

        const unitWeight = 1 / totalUnits;

        for (let i = 0; i < totalUnits; i++) {
            const unit = state.units[i];

            if (unit.height <= 0) {
                totalProgress += unitWeight;
                continue;
            }

            if (scroll >= unit.endScroll) {
                totalProgress += unitWeight;
                currentUnitIndex = i + 1;
                continue;
            }

            if (scroll >= unit.startScroll && scroll < unit.endScroll) {
                currentUnitIndex = i;
                const scrolledInUnit = scroll - unit.startScroll;
                unitProgress = Math.min(1, Math.max(0, scrolledInUnit / unit.height));
                totalProgress += (unitProgress * unitWeight);
                break;
            }

            if (scroll < unit.startScroll) {
                 currentUnitIndex = i;
                 unitProgress = 0;
                 break;
            }
        }

        totalProgress = Math.min(1, totalProgress);

        const scrollMax = editor.scrollHeight - editor.clientHeight;
        if (scroll >= scrollMax && scrollMax > 0) {
            currentUnitIndex = totalUnits - 1;
            unitProgress = 1;
            totalProgress = 1;
        }

        const result = { currentUnitIndex, unitProgress, unitWeight: unitWeight, totalProgress, totalUnits };
        _progressCache = result;
        _progressCacheFrame = _frameCounter;
        return result;
    }

    function updateProgressBars(currentUnitIndex, unitProgress) {
        const bars = topProgressContainer.querySelectorAll('.unit-progress-bar-inner');

        bars.forEach((bar, index) => {
            if (index < currentUnitIndex) {
                bar.style.width = '100%';
            } else if (index === currentUnitIndex) {
                bar.style.width = `${Math.round(unitProgress * 100)}%`;
            } else {
                bar.style.width = '0%';
            }
        });
    }

    function saveToStorage() {
      try {
        localStorage.setItem('editorContent', editor.innerHTML);
        localStorage.setItem('editorScrollPosition', editor.scrollTop);
        return true;
      } catch (e) {
        showNotification('Failed to save your work.', 3000);
        return false;
      }
    }

    function loadContent() {
      try {
        const saved = localStorage.getItem('editorContent');
        if (saved) {
          editor.innerHTML = saved;
        }
      } catch (e) {
        // Silently fall back to default content
      }
    }

    function saveUndoHistory() {
        try {
            localStorage.setItem('editorUndoHistory', JSON.stringify(state.undoHistory));
        } catch (e) {
            // Undo history save failed, not critical
        }
    }

    function loadUndoHistory() {
        try {
            const savedHistory = localStorage.getItem('editorUndoHistory');
            if (savedHistory) {
                state.undoHistory = JSON.parse(savedHistory);
            }
        } catch (e) {
            state.undoHistory = [];
        }
    }

    function restoreScroll() {
      try {
        const scrollPosition = localStorage.getItem('editorScrollPosition');
        if (scrollPosition !== null && scrollPosition !== undefined) {
          const scrollValue = parseInt(scrollPosition, 10);
          if (!isNaN(scrollValue)) {
            editor.scrollTop = scrollValue;
            requestAnimationFrame(() => {
              _frameCounter++;
              updateStatus();
            });
          }
        }
      } catch (e) {
        // Scroll restore failed, not critical
      }
    }

    function saveState() {
      saveToStorage();
      saveUndoHistory();
    }

    function toggleTheme() {
      state.isDarkMode = !state.isDarkMode;
      document.body.classList.toggle('dark-mode', state.isDarkMode);
      themeToggle.textContent = state.isDarkMode ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('editorTheme', state.isDarkMode ? 'dark' : 'light');
    }

    function loadTheme() {
      const savedTheme = localStorage.getItem('editorTheme');
      if (savedTheme === 'dark') {
        state.isDarkMode = true;
        document.body.classList.add('dark-mode');
        themeToggle.textContent = '‚òÄÔ∏è';
      }
    }

    // Notification with stacking fix - cancels previous notification timers
    function showNotification(message, duration = config.notificationDuration) {
      clearTimeout(state.notificationTimer);
      clearTimeout(state.notificationFadeTimer);

      notification.textContent = message;
      notification.style.display = 'block';
      notification.style.opacity = '1';

      state.notificationTimer = setTimeout(() => {
        notification.style.opacity = '0';
        state.notificationFadeTimer = setTimeout(() => {
          notification.style.display = 'none';
        }, 300);
      }, duration);
    }

    document.addEventListener('DOMContentLoaded', init);
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      init();
    }
  </script>
</body>
</html>
