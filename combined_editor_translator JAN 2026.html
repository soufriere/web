<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Transcript Text Editor - Unit Tracker</title>
  <style>
    /* Theme variables */
    :root {
      --primary-bg: #fff;
      --primary-text: #333;
      --secondary-bg: #f5f5f5;
      --button-bg: #444;
      --button-hover: #666;
      --button-text: #fff;
      --status-bg: #222;
      --status-text: #fff;
      --notification-bg: rgba(0,0,0,0.8);
      --format-btn-bg: #ddd;
      --format-btn-text: #333;
      --progress-bar-bg: #0066ff;
      --progress-marker: #ffffff;
      --jump-btn-bg: #5a5a5a;
      --jump-btn-hover: #777777;
      --jump-btn-active: #0099ff;
      --analyze-btn-bg: #0099ff;
      --analyze-btn-hover: #007acc;
      --translate-btn-bg: #9b59b6;
      --translate-btn-hover: #8e44ad;
    }

    .dark-mode {
      --primary-bg: #222;
      --primary-text: #eee;
      --secondary-bg: #444;
      --button-bg: #555;
      --button-hover: #777;
      --format-btn-bg: #555;
      --format-btn-text: #eee;
      --jump-btn-bg: #333;
      --jump-btn-hover: #555;
      --analyze-btn-bg: #007acc; 
      --analyze-btn-hover: #005a99;
      --translate-btn-bg: #8e44ad;
      --translate-btn-hover: #71368a;
    }

    /* Progress bar at top of screen */
    #top-progress-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 6px;
      background-color: var(--secondary-bg);
      z-index: 1000;
      overflow: hidden;
      display: flex;
    }

    .unit-progress-bar {
      height: 100%;
      width: 0;
      background-color: transparent;
      position: relative;
      overflow: hidden;
    }

    .unit-progress-bar-inner {
      height: 100%;
      width: 0%;
      background-color: var(--progress-bar-bg);
      transition: width 0.3s ease;
      position: absolute;
      top: 0;
      left: 0;
    }
    
    .progress-markers {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      pointer-events: none;
    }

    .progress-marker {
      flex: 1;
      height: 100%;
      border-right: 2px solid var(--progress-marker);
      box-sizing: border-box;
    }

    .progress-marker:last-child {
      border-right: none;
    }

    /* Base styles */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      color: var(--primary-text);
      background-color: var(--primary-bg);
      transition: background-color 0.3s, color 0.3s;
    }
    
    /* Progress zones */
    .progress-zones-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      display: flex;
      flex-direction: column;
    }

    .progress-zone {
      width: 100%;
      height: 10%;
      background-color: transparent;
      transition: background-color 0.5s ease;
    }

    .progress-zone.active {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .dark-mode .progress-zone.active {
      background-color: rgba(255, 255, 255, 0.05);
    }

    /* Layout */
    #status-bar {
      position: sticky;
      top: 0;
      background: var(--status-bg);
      color: var(--status-text);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      z-index: 100;
    }

    #main-status-row {
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    #unit-jump-row {
      padding: 0 1rem 0.3rem 1rem;
      display: flex;
      gap: 0.15rem; 
      flex-wrap: wrap;
      max-height: 30px;
      overflow-y: auto;
    }
    
    .unit-group {
        display: flex;
        gap: 0.15rem;
    }

    /* Jump buttons style */
    .jump-btn {
      background-color: var(--jump-btn-bg);
      color: var(--button-text);
      border: 1px solid var(--jump-btn-bg);
      padding: 0.2rem 0.5rem;
      font-size: 0.7rem;
      line-height: 1.2;
      transition: background-color 0.2s, border-color 0.2s;
      white-space: nowrap;
    }
    
    .jump-btn.copy-btn {
        padding: 0.2rem 0.35rem;
        font-size: 0.65rem;
    }

    .jump-btn:hover {
      background-color: var(--jump-btn-hover);
    }

    .jump-btn.active {
      background-color: var(--jump-btn-active);
      border-color: var(--jump-btn-active);
    }

    #editor-container {
      flex: 1;
      position: relative;
      display: flex;
      justify-content: center;
      overflow: hidden;
    }

    #editor {
      padding: 1.5rem;
      border: none;
      outline: none;
      overflow-y: auto;
      line-height: 1.5;
      max-width: 800px;
      width: 100%;
      box-sizing: border-box;
      background-color: transparent;
      color: var(--primary-text);
      height: 100%;
      position: relative;
      z-index: 10;
      font-size: 18pt; 
    }

    /* Controls */
    .status-left {
      display: flex;
      flex-direction: row; 
      gap: 0.5rem; 
      align-items: center;
      font-size: 0.85rem;
    }
    
    .controls {
      display: flex;
      gap: 0.3rem;
      align-items: center;
    }

    button {
      cursor: pointer;
      border-radius: 3px;
      border: none;
      transition: background-color 0.2s;
    }

    #save-btn, #export-btn, #undo-btn, #history-btn, #clear-storage-btn {
      background: var(--button-bg);
      color: var(--button-text);
      padding: 0.35rem 0.7rem;
      font-size: 0.75rem;
    }
    
    #analyze-btn {
      background: var(--analyze-btn-bg);
      color: var(--button-text);
      padding: 0.35rem 0.7rem;
      font-size: 0.75rem;
    }

    #save-btn:hover, #export-btn:hover, #undo-btn:hover, #history-btn:hover, #clear-storage-btn:hover {
      background: var(--button-hover);
    }
    
    #analyze-btn:hover {
      background: var(--analyze-btn-hover);
    }
    
    #clear-storage-btn {
      background: #d32f2f;
    }
    
    #clear-storage-btn:hover {
      background: #b71c1c;
    }

    #theme-toggle {
      background: none;
      color: var(--status-text);
      padding: 0.2rem;
      font-size: 0.9rem;
    }

    /* Pomodoro Indicator Styles */
    #pomodoro-indicators {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 3px;
        padding-left: 0.3rem; 
        font-size: 0.8rem;
    }
    .pomodoro-square {
        width: 16px;
        height: 16px;
        border: 1px solid var(--button-bg);
        background-color: transparent;
        position: relative;
        overflow: hidden;
        display: inline-block;
        box-sizing: border-box;
    }
    .pomodoro-square-fill {
        position: absolute;
        top: 0;
        left: 0;
        height: 100%;
        width: 0%;
        background-color: #4CAF50;
        transition: width 0.3s ease;
    }
    .pomodoro-square.completed .pomodoro-square-fill {
        width: 100%;
    }
    .pomodoro-square.current {
        border-color: var(--primary-text);
        border-width: 1.5px;
    }
    .pomodoro-square.current .pomodoro-square-fill {
        background-color: #FFC107;
    }

    /* M/R Clickable Prefix */
    .mr-swap-link {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-style: dotted;
        color: inherit;
        user-select: none;
    }
    
    .mr-swap-link:hover {
        text-decoration-style: solid;
        opacity: 0.7;
    }

    /* Notification */
    #notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: var(--notification-bg);
      color: var(--status-text);
      padding: 10px 15px;
      border-radius: 4px;
      display: none;
      z-index: 2000;
      transition: opacity 0.3s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }

    #file-id-input, #set-file-id-btn, #file-id-display {
        display: none !important;
    }

    @media (max-width: 600px) {
      #main-status-row {
        flex-direction: column;
        gap: 0.5rem;
        align-items: flex-start;
      }
      .controls {
        width: 100%;
        justify-content: flex-end;
      }
      #editor {
        padding: 1rem;
      }
      #pomodoro-indicators {
        padding-left: 0;
        margin-top: 0.5rem;
      }
    }
  
    /* Translation Settings Modal */
    #translation-settings-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal-content {
      background: var(--primary-bg);
      color: var(--primary-text);
      padding: 2rem;
      border-radius: 8px;
      width: 90%;
      max-width: 700px;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.5rem;
    }

    .close-modal {
      background: var(--button-bg);
      color: var(--button-text);
      border: none;
      padding: 0.5rem 1rem;
      cursor: pointer;
      border-radius: 4px;
      font-size: 1rem;
    }

    .close-modal:hover {
      background: var(--button-hover);
    }

    .settings-group {
      margin-bottom: 1.5rem;
    }

    .settings-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .settings-group select,
    .settings-group input[type="number"] {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid var(--secondary-bg);
      border-radius: 4px;
      background: var(--primary-bg);
      color: var(--primary-text);
      font-size: 0.9rem;
    }

    .settings-group textarea {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--secondary-bg);
      border-radius: 4px;
      background: var(--primary-bg);
      color: var(--primary-text);
      font-family: inherit;
      font-size: 0.85rem;
      resize: vertical;
      min-height: 80px;
    }

    .settings-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    /* Translation Progress Bar */
    #translation-progress-container {
      display: none;
      position: fixed;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      background: var(--status-bg);
      color: var(--status-text);
      padding: 1rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      z-index: 1500;
      min-width: 300px;
    }

    .translation-progress-bar {
      height: 8px;
      background: var(--secondary-bg);
      border-radius: 4px;
      overflow: hidden;
      margin-top: 0.5rem;
    }

    .translation-progress-fill {
      height: 100%;
      background: var(--translate-btn-bg);
      transition: width 0.3s ease;
      width: 0%;
    }

    .translation-progress-label {
      font-size: 0.85rem;
      margin-top: 0.5rem;
      font-family: monospace;
    }

    #translate-btn, #translate-settings-btn {
      background: var(--translate-btn-bg);
      color: var(--button-text);
      padding: 0.35rem 0.7rem;
      font-size: 0.75rem;
    }

    #translate-btn:hover, #translate-settings-btn:hover {
      background: var(--translate-btn-hover);
    }

  </style>
</head>
<body>
  <div id="top-progress-container"></div>
  <div id="status-bar">
    <div id="main-status-row">
      <div class="status-left">
        <span id="progress">Unit 1/3 â€¢ 0%</span>
        <span id="eta" style="font-size: 0.8rem;">0w â€¢ 0min</span>
        <div id="pomodoro-indicators">Pomodoros: 0</div>
      </div>
      <div class="controls">
                <button id="theme-toggle" aria-label="Toggle dark mode" title="Dark mode">ðŸŒ™</button>
        <button id="analyze-btn" aria-label="Analyze and Format" title="Analyze & Format">Format</button>
        <button id="undo-btn" aria-label="Undo last action" title="Undo">â†¤</button>
        <button id="export-btn" aria-label="Export content" title="Export">ðŸ“„</button>
        <button id="save-btn" aria-label="Save content" title="Save">ðŸ’¾</button>
      </div>
    </div>
    <div id="unit-jump-row"></div>
  </div>

  <div id="editor-container">
    <div class="progress-zones-container" id="progress-zones"></div>
    <div id="editor" contenteditable="true" aria-label="Text editor with auto-formatting" role="textbox">
      <p>Unit 1: Edit your pre-loaded content here.</p>
      <p>M: This is a marked paragraph that should be bold.</p>
      <p>R: This should not be bold.</p>
      <p>***</p>
      <p>Unit 2: This is the start of the second unit, separated by three asterisks.</p>
      <p>M: How far are we into this project?</p>
      <p>R: We're making good progress now.</p>
      <p>***</p>
      <p>Unit 3: This is the final unit.</p>
      <p>Final paragraph...</p>
    </div>
  </div>
  
  <div id="notification" role="status" aria-live="polite"></div>



  <script>
    // DOM Elements
    const editor = document.getElementById('editor');
    const etaDisplay = document.getElementById('eta');
    const progressDisplay = document.getElementById('progress');
    const saveBtn = document.getElementById('save-btn');
    const exportBtn = document.getElementById('export-btn');
    const notification = document.getElementById('notification');
    const themeToggle = document.getElementById('theme-toggle');
    const clearStorageBtn = document.getElementById('clear-storage-btn');
    const progressZones = document.getElementById('progress-zones');
    const topProgressContainer = document.getElementById('top-progress-container');
    const unitJumpRow = document.getElementById('unit-jump-row'); 
    const undoBtn = document.getElementById('undo-btn'); 
    const historyBtn = document.getElementById('history-btn'); 
    const pomodoroIndicators = document.getElementById('pomodoro-indicators'); 
    const analyzeBtn = document.getElementById('analyze-btn'); 

    // State
    const state = {
      lastScrollTime: Date.now(),
      wordCount: 0,
      isDarkMode: false,
      scrollData: [],
      eta: 120, 
      minEta: 120, 
      undoHistory: [], 
      isUndoing: false,
      timers: {
        format: null,
        undo: null,
        unitCalc: null 
      },
      units: [], 
      totalScrollableHeight: 0
    };

    // Config
    const config = {
      undoLimit: 50,
      formatDelay: 300,
      undoDelay: 500,
      unitCalcDelay: 1000, 
      scrollSamplesLimit: 30,
      notificationDuration: 2000,
      statusInterval: 5000 
    };

    // Initialize
    function init() {
      loadContent();
      loadUndoHistory(); 
      setupEvents();
      countWords();
      loadTheme();
      
      requestAnimationFrame(() => {
        manualAnalyzeAndFormat(); 
        
        setTimeout(() => {
          restoreScroll();
          saveUndo();
        }, 100);
      });
      
      setInterval(updateStatus, config.statusInterval);
    }
    
    function createProgressMarkers() {
      progressZones.innerHTML = '';
      
      for (let i = 1; i <= 10; i++) {
        const zone = document.createElement('div');
        zone.className = 'progress-zone';
        zone.dataset.progress = i / 10;
        progressZones.appendChild(zone);
      }
    }
    
    function updateProgressMarkers(currentProgress) {
      const zones = progressZones.querySelectorAll('.progress-zone');
      
      zones.forEach(zone => {
        const zoneProgress = parseFloat(zone.dataset.progress);
        if (currentProgress >= zoneProgress) {
          zone.classList.add('active');
        } else {
          zone.classList.remove('active');
        }
      });
    }
    
    // Event setup
    function setupEvents() {
      editor.addEventListener('scroll', onScroll);
      editor.addEventListener('input', onInput);
      editor.addEventListener('paste', onPaste); 
      
      saveBtn.addEventListener('click', onSave);
      exportBtn.addEventListener('click', onExport);
      themeToggle.addEventListener('click', toggleTheme);
      clearStorageBtn.addEventListener('click', clearAllStorage);
      undoBtn.addEventListener('click', performUndo); 
      historyBtn.addEventListener('click', downloadHistory); 
      analyzeBtn.addEventListener('click', manualAnalyzeAndFormat); 

      document.addEventListener('keydown', handleKeys);
      
      window.addEventListener('beforeunload', saveState);
    }
    
    // Keyboard shortcuts
    function handleKeys(e) {
      if (e.ctrlKey) {
        switch(e.key) {
          case 'z':
            e.preventDefault();
            performUndo();
            break;
        }
      }
    }
    
    // Handle scroll
    function onScroll() {
      state.lastScrollTime = Date.now();
      
      const progress = getProgress();
      if (state.scrollData.length > 0) {
        const lastProgress = state.scrollData[state.scrollData.length - 1].progress;
        if (lastProgress - progress > 0.2) {
          state.scrollData = [];
          if (state.eta > 0) {
            state.minEta = Math.round(state.eta * 1.1);
          }
        }
      }
      
      recordProgress();
      updateStatus();
    }
    
    // Handle input
    function onInput() {
      countWords();
      recordProgress();
      
      if (!state.isUndoing) {
        clearTimeout(state.timers.undo);
        state.timers.undo = setTimeout(saveUndo, config.undoDelay);
      }
      
      updateStatus();
    }
    
    // Save to undo history
    function saveUndo() {
      const currentContent = editor.innerHTML;
      const lastContent = state.undoHistory.length > 0 ? state.undoHistory[state.undoHistory.length - 1].content : null;
      
      if (currentContent !== lastContent) {
        state.undoHistory.push({ content: currentContent, timestamp: Date.now() });
        saveUndoHistory(); 
      }
      
      if (state.undoHistory.length > config.undoLimit) {
        state.undoHistory.shift();
      }
      
      updateHistoryButtonText(); 
    }
    
    // Perform undo
    function performUndo() {
      if (state.undoHistory.length <= 1) { 
          showNotification('Nothing left to undo.', 1500);
          return;
      }
      
      state.undoHistory.pop(); 
      const prevState = state.undoHistory[state.undoHistory.length - 1]; 
      
      state.isUndoing = true;
      editor.innerHTML = prevState.content;
      
      saveUndoHistory();
      
      setTimeout(() => {
        state.isUndoing = false;
        manualAnalyzeAndFormat();
      }, 10);
      
      showNotification('Undo successful (Ctrl+Z)', 1500);
    }

    function updateHistoryButtonText() {
        const count = Math.max(0, state.undoHistory.length - 1);
        historyBtn.textContent = `History (${count})`;
    }

    function downloadHistory() {
        if (state.undoHistory.length <= 1) {
            showNotification('No history versions available to download.', 2000);
            return;
        }

        const historyToSave = state.undoHistory.slice(0, -1); 
        const maxVersions = 20;
        let output = `--- Editor History Dump ---\n`;
        let count = 0;
        const oneHourAgo = Date.now() - 3600000; 

        for (let i = historyToSave.length - 1; i >= 0; i--) {
            const historyItem = historyToSave[i];
            
            if (count >= maxVersions && historyItem.timestamp < oneHourAgo) {
                break;
            }

            const timestamp = new Date(historyItem.timestamp).toLocaleString();
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = historyItem.content;
            const textContent = tempDiv.innerText;

            output += `\n======== VERSION ${historyToSave.length - i} (${timestamp}) ========\n`;
            output += textContent;
            output += `\n\n`;
            count++;
        }

        const blob = new Blob([output], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `transcript-history-${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }, 100);
        showNotification(`Downloaded history of ${count} versions.`, 2000);
    }
    
    
    // Save content
    function onSave() {
      manualAnalyzeAndFormat();
      
      if (saveToStorage()) {
        saveBtn.textContent = "SAVED!";
        showNotification('Content saved successfully');
        setTimeout(() => { saveBtn.textContent = "ðŸ’¾"; }, 1500);
      }
    }
    
    // Export content
    function onExport() {
      try {
        manualAnalyzeAndFormat();
        
        const content = editor.innerText;
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `transcript-export-${new Date().toISOString().slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);
        showNotification('Content exported successfully');
      } catch (err) {
        console.error('Export error:', err);
        showNotification('Error exporting content', 3000);
      }
    }
    
    function getProgress() {
      const { totalProgress } = getCurrentUnitProgress();
      return totalProgress;
    }

    function recordProgress() {
      const progress = getProgress();
      if (isNaN(progress) || progress < 0 || progress > 1) return;
      
      const now = Date.now();
      
      if (state.scrollData.length > 0) {
        const last = state.scrollData[state.scrollData.length - 1];
        if (progress === last.progress && now - last.time < 30000) {
          return;
        }
      }
      
      state.scrollData.push({ time: now, progress });
      
      if (state.scrollData.length > config.scrollSamplesLimit) {
        state.scrollData.shift();
      }
    }

    function countWords() {
      const text = editor.innerText || '';
      state.wordCount = text.split(/\s+/).filter(Boolean).length;
    }

    function updatePomodoroIndicators(total, completed) {
        if (!pomodoroIndicators) return;

        pomodoroIndicators.innerHTML = '';
        
        if (total === 0) {
            pomodoroIndicators.textContent = 'Pomodoros: 0';
            return;
        }

        const label = document.createElement('span');
        label.textContent = 'Pomodoros: ';
        label.style.marginRight = '2px';
        pomodoroIndicators.appendChild(label);

        const maxSquares = 10; 
        const displayTotal = Math.min(total, maxSquares);
        
        // Calculate progress within the current pomodoro
        const { totalProgress } = getCurrentUnitProgress();
        const exactProgress = totalProgress * total; // Exact progress in pomodoros
        const currentPomodoroIndex = Math.floor(exactProgress);
        const currentPomodoroProgress = exactProgress - currentPomodoroIndex; // Fractional progress (0-1)

        for (let i = 0; i < displayTotal; i++) {
            const square = document.createElement('div');
            square.className = 'pomodoro-square';
            
            const fill = document.createElement('div');
            fill.className = 'pomodoro-square-fill';
            
            if (i < currentPomodoroIndex) {
                // Completed pomodoros
                square.classList.add('completed');
            } else if (i === currentPomodoroIndex) {
                // Current pomodoro being worked on
                square.classList.add('current');
                fill.style.width = `${Math.round(currentPomodoroProgress * 100)}%`;
            }
            
            square.appendChild(fill);
            pomodoroIndicators.appendChild(square);
        }

        if (total > maxSquares) {
             const ellipsis = document.createElement('span');
             ellipsis.style.fontSize = '12px';
             ellipsis.style.paddingLeft = '5px';
             ellipsis.style.color = 'var(--status-text)';
             ellipsis.textContent = ` ... (+${total - maxSquares})`;
             pomodoroIndicators.appendChild(ellipsis);
        }
    }

    function manualAnalyzeAndFormat() {
        showNotification('Running analysis and formatting...', 500);
        
        formatMarkedText();
        addMRSwapButtons();
        removeEmptyLines();
        countWords(); 
        calculateUnitsAndScrollPositions();
        
        showNotification('Analysis and formatting complete.', 1000);
    }
    
    function removeEmptyLines() {
      const blocks = editor.querySelectorAll('p');
      const toRemove = [];
      
      blocks.forEach(block => {
        const text = (block.textContent || '').trim();
        if (text === '' || text === '<br>') {
          toRemove.push(block);
        }
      });
      
      toRemove.forEach(block => block.remove());
    }

    function updateStatus() {
      recordProgress();
      
      const { 
        currentUnitIndex, unitProgress, totalProgress, totalUnits 
      } = getCurrentUnitProgress();
      
      updateProgressBars(currentUnitIndex, unitProgress);
      updateUnitJumpButtons(currentUnitIndex);
      
      if (!isNaN(totalProgress)) {
        const overallPercent = Math.min(100, Math.max(0, Math.round(totalProgress * 100)));
        const unitPercent = Math.min(100, Math.max(0, Math.round(unitProgress * 100)));
        
        progressDisplay.textContent = `Unit ${currentUnitIndex + 1}/${totalUnits} â€¢ ${unitPercent}%`;
        
        updateProgressMarkers(totalProgress);
      }
      
      updateHistoryButtonText();
  
      const WORDS_PER_45_MIN = 6000;
      const MINUTES_PER_BENCHMARK = 45;
      const POMODORO_MINUTES = 25;
      
      const totalExpectedMins = Math.round((state.wordCount / WORDS_PER_45_MIN) * MINUTES_PER_BENCHMARK);
      
      const remainingProgress = Math.max(0, 1 - totalProgress);
      const remainingMins = Math.round(totalExpectedMins * remainingProgress);
      
      etaDisplay.textContent = `${state.wordCount}w â€¢ ${remainingMins}min`;
      
      const totalPomodoros = Math.ceil(totalExpectedMins / POMODORO_MINUTES);
      const completedPomodoros = Math.floor(totalPomodoros * totalProgress); 

      updatePomodoroIndicators(totalPomodoros, completedPomodoros);
    }

    function formatMarkedText() {
      const blocks = editor.querySelectorAll('p');
      const toRemove = [];
      
      blocks.forEach(block => {
        const text = (block.textContent || '').trim();
        
        if (text === '' || text === '<br>') {
          toRemove.push(block);
          return;
        }
        
        if (text.startsWith("M:")) {
          const strong = block.querySelector('strong');
          if (!strong || strong.textContent.trim() !== text) {
            const existingStrongs = block.querySelectorAll('strong');
            existingStrongs.forEach(s => {
              while (s.firstChild) {
                block.insertBefore(s.firstChild, s);
              }
              s.remove();
            });
            const content = block.innerHTML;
            block.innerHTML = `<strong>${content}</strong>`;
          }
        } 
        else if (text.startsWith("R:") || /^\*{3,}$/.test(text)) {
          const strongElements = block.querySelectorAll('strong');
          strongElements.forEach(strong => {
            while (strong.firstChild) {
              block.insertBefore(strong.firstChild, strong);
            }
            strong.remove();
          });
        }
      });
      
      toRemove.forEach(block => block.remove());
    }

    function addMRSwapButtons() {
        // First, remove all existing swap links
        const existingLinks = editor.querySelectorAll('.mr-swap-link');
        existingLinks.forEach(link => {
            // Replace the span with just its text content
            const textNode = document.createTextNode(link.textContent);
            link.parentNode.replaceChild(textNode, link);
        });
        
        const blocks = editor.querySelectorAll('p');
        
        blocks.forEach(block => {
            const text = (block.textContent || '').trim();
            
            if (text.startsWith("M:") || text.startsWith("R:")) {
                // Walk through the block's child nodes to find the M: or R: prefix
                const walker = document.createTreeWalker(
                    block,
                    NodeFilter.SHOW_TEXT,
                    null,
                    false
                );
                
                let textNode;
                while (textNode = walker.nextNode()) {
                    const nodeText = textNode.nodeValue || '';
                    const trimmedText = nodeText.trim();
                    
                    if (trimmedText.startsWith('M:') || trimmedText.startsWith('R:')) {
                        // Found the text node with the prefix
                        const prefix = trimmedText.substring(0, 2); // "M:" or "R:"
                        
                        // Find where the prefix starts in the actual node text
                        const prefixIndex = nodeText.indexOf(prefix);
                        
                        if (prefixIndex !== -1) {
                            // Split the text node into three parts
                            const beforePrefix = nodeText.substring(0, prefixIndex);
                            const afterPrefix = nodeText.substring(prefixIndex + 2);
                            
                            // Create the clickable span for the prefix
                            const span = document.createElement('span');
                            span.className = 'mr-swap-link';
                            span.textContent = prefix;
                            span.title = 'Click to swap M: â†” R: from here down in this unit';
                            span.contentEditable = false;
                            
                            span.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                swapMRInUnit(block);
                            });
                            
                            // Create new text nodes
                            const beforeNode = document.createTextNode(beforePrefix);
                            const afterNode = document.createTextNode(afterPrefix);
                            
                            // Replace the original text node with the three pieces
                            const parent = textNode.parentNode;
                            parent.insertBefore(beforeNode, textNode);
                            parent.insertBefore(span, textNode);
                            parent.insertBefore(afterNode, textNode);
                            parent.removeChild(textNode);
                            
                            break; // Only process the first occurrence
                        }
                    }
                }
            }
        });
    }
    
    function swapMRInUnit(startingBlock) {
        // Find which unit this block belongs to
        let currentUnit = null;
        for (let i = 0; i < state.units.length; i++) {
            const unit = state.units[i];
            if (unit.children && Array.from(unit.children).includes(startingBlock)) {
                currentUnit = unit;
                break;
            }
        }
        
        if (!currentUnit) {
            console.log('Could not find unit for block');
            return;
        }
        
        // Find the index of startingBlock within the unit
        const unitChildren = Array.from(currentUnit.children);
        const startIndex = unitChildren.indexOf(startingBlock);
        
        if (startIndex === -1) {
            console.log('Could not find startIndex');
            return;
        }
        
        console.log(`Swapping from index ${startIndex} in unit with ${unitChildren.length} children`);
        
        // Swap M: and R: for all paragraphs from this one onwards in the unit
        for (let i = startIndex; i < unitChildren.length; i++) {
            const block = unitChildren[i];
            const text = (block.textContent || '').trim();
            
            console.log(`Block ${i}: "${text.substring(0, 20)}..."`);
            
            if (text.startsWith("M:")) {
                console.log('Found M:, swapping to R:');
                // Find and replace M: with R:
                replacePrefix(block, "M:", "R:");
                
                // Remove strong formatting if it exists
                const strongElements = block.querySelectorAll('strong');
                strongElements.forEach(strong => {
                    while (strong.firstChild) {
                        block.insertBefore(strong.firstChild, strong);
                    }
                    strong.remove();
                });
            } else if (text.startsWith("R:")) {
                console.log('Found R:, swapping to M:');
                // Replace "R:" with "M:"
                replacePrefix(block, "R:", "M:");
                
                // Add strong formatting
                const existingStrongs = block.querySelectorAll('strong');
                existingStrongs.forEach(s => {
                    while (s.firstChild) {
                        block.insertBefore(s.firstChild, s);
                    }
                    s.remove();
                });
                const content = block.innerHTML;
                block.innerHTML = `<strong>${content}</strong>`;
            }
        }
        
        // Re-add swap links after the swap
        addMRSwapButtons();
        saveState();
        showNotification('M: and R: swapped from this point onwards in unit', 1500);
    }
    
    function replacePrefix(block, oldPrefix, newPrefix) {
        // Walk through all nodes including the swap link
        const walker = document.createTreeWalker(
            block,
            NodeFilter.SHOW_ALL,
            null,
            false
        );
        
        let node;
        while (node = walker.nextNode()) {
            if (node.nodeType === Node.TEXT_NODE) {
                const nodeText = node.nodeValue || '';
                if (nodeText.includes(oldPrefix)) {
                    node.nodeValue = nodeText.replace(oldPrefix, newPrefix);
                    console.log(`Replaced ${oldPrefix} with ${newPrefix} in text node`);
                    break;
                }
            } else if (node.nodeType === Node.ELEMENT_NODE && node.classList && node.classList.contains('mr-swap-link')) {
                // Replace the span's text content
                if (node.textContent === oldPrefix) {
                    node.textContent = newPrefix;
                    console.log(`Replaced ${oldPrefix} with ${newPrefix} in swap link`);
                    break;
                }
            }
        }
    }

    function calculateUnitsAndScrollPositions() {
        state.units = [];
        const children = Array.from(editor.children);
        
        console.log('calculateUnitsAndScrollPositions called. editor.children.length:', children.length);
        console.log('editor.scrollHeight:', editor.scrollHeight, 'editor.clientHeight:', editor.clientHeight);
        
        if (children.length === 0) {
            state.totalScrollableHeight = 0;
            console.log('No children, returning early.');
            updateProgressContainerUI();
            createUnitJumpButtons();
            return;
        }

        let currentUnit = { startScroll: 0, children: [] };

        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            const text = child.textContent || '';
            const trimmedText = text.trim();
            
            const isSeparator = /^\*{3,}$/.test(trimmedText);
            
            console.log(`Child ${i}: tag=${child.tagName}, text="${trimmedText.substring(0, 30)}${trimmedText.length > 30 ? '...' : ''}", isSeparator=${isSeparator}, offsetTop=${child.offsetTop}, offsetHeight=${child.offsetHeight}`);

            if (isSeparator) {
                if (currentUnit.children.length > 0) {
                    const lastChild = currentUnit.children[currentUnit.children.length - 1];
                    currentUnit.endScroll = lastChild.offsetTop + lastChild.offsetHeight;
                    currentUnit.height = currentUnit.endScroll - currentUnit.startScroll;
                    console.log(`Found separator. Finalizing unit with ${currentUnit.children.length} children. Height: ${currentUnit.height}, startScroll: ${currentUnit.startScroll}, endScroll: ${currentUnit.endScroll}`);
                    state.units.push(currentUnit);
                }
                
                currentUnit = {
                    startScroll: child.offsetTop + child.offsetHeight,
                    children: []
                };
            } else {
                currentUnit.children.push(child);
            }
        }

        if (currentUnit.children.length > 0) {
            const lastChild = currentUnit.children[currentUnit.children.length - 1];
            currentUnit.endScroll = lastChild.offsetTop + lastChild.offsetHeight;
            currentUnit.height = currentUnit.endScroll - currentUnit.startScroll;
            console.log(`Finalizing last unit with ${currentUnit.children.length} children. Height: ${currentUnit.height}, startScroll: ${currentUnit.startScroll}, endScroll: ${currentUnit.endScroll}`);
            state.units.push(currentUnit);
        }
        
        if (state.units.length === 0 && children.length > 0) {
             const lastChild = children[children.length - 1];
             console.log('No separators found, treating entire document as one unit. lastChild.offsetTop:', lastChild.offsetTop, 'lastChild.offsetHeight:', lastChild.offsetHeight);
             state.units.push({
                startScroll: 0,
                endScroll: lastChild.offsetTop + lastChild.offsetHeight,
                height: lastChild.offsetTop + lastChild.offsetHeight,
                children: children
            });
        }
        
        console.log('Total units calculated:', state.units.length);
        state.units.forEach((unit, idx) => {
            console.log(`Unit ${idx}: startScroll=${unit.startScroll}, endScroll=${unit.endScroll}, height=${unit.height}, children=${unit.children.length}`);
        });
        
        state.totalScrollableHeight = editor.scrollHeight - editor.clientHeight;
        console.log('Total scrollable height:', state.totalScrollableHeight);
        
        updateProgressContainerUI();
        createUnitJumpButtons();
        
        updateStatus();
    }
    
    function updateProgressContainerUI() {
        topProgressContainer.innerHTML = '';

        const totalUnits = state.units.length;
        if (totalUnits === 0) return;

        const unitWidth = 100 / totalUnits;

        state.units.forEach((unit, index) => {
            const unitBar = document.createElement('div');
            unitBar.className = 'unit-progress-bar';
            unitBar.style.width = `${unitWidth}%`;
            unitBar.dataset.unitIndex = index;

            const unitBarInner = document.createElement('div');
            unitBarInner.className = 'unit-progress-bar-inner';
            unitBar.appendChild(unitBarInner);

            const markers = document.createElement('div');
            markers.className = 'progress-markers';
            for (let i = 0; i < 10; i++) {
                const marker = document.createElement('div');
                marker.className = 'progress-marker';
                markers.appendChild(marker);
            }
            unitBar.appendChild(markers);

            topProgressContainer.appendChild(unitBar);
        });
    }

    function createUnitJumpButtons() {
        unitJumpRow.innerHTML = '';
        state.units.forEach((unit, index) => {
            const unitGroup = document.createElement('div');
            unitGroup.className = 'unit-group';

            const jumpButton = document.createElement('button');
            jumpButton.className = 'jump-btn';
            
            // Extract first 5 chars from first line of unit
            let buttonLabel = `Unit ${index + 1}`;
            if (unit.children && unit.children.length > 0) {
                const firstElement = unit.children[0];
                const firstLineText = firstElement.innerText || firstElement.textContent || '';
                const firstLine = firstLineText.split('\n')[0].trim();
                if (firstLine.length > 0) {
                    buttonLabel = firstLine.substring(0, 5);
                }
            }
            
            jumpButton.textContent = buttonLabel;
            jumpButton.dataset.unitIndex = index;
            jumpButton.dataset.scrollPosition = unit.startScroll;
            
            jumpButton.addEventListener('click', (e) => {
                const scrollPos = parseInt(e.target.dataset.scrollPosition);
                editor.scrollTop = scrollPos;
            });
            
            const copyButton = document.createElement('button');
            copyButton.className = 'jump-btn copy-btn';
            copyButton.textContent = 'ðŸ“‹';
            copyButton.title = `Copy Unit ${index + 1} Text`;
            copyButton.dataset.unitIndex = index;

            copyButton.addEventListener('click', (e) => {
                const unitIndexToCopy = parseInt(e.currentTarget.dataset.unitIndex);
                copyUnitText(unitIndexToCopy);
            });

            unitGroup.appendChild(jumpButton);
            unitGroup.appendChild(copyButton);
            unitJumpRow.appendChild(unitGroup);
        });
    }

    function copyUnitText(unitIndex) {
        const unit = state.units[unitIndex];
        if (!unit || unit.children.length === 0) {
            showNotification(`Unit ${unitIndex + 1} is empty.`, 2000);
            return;
        }

        let unitText = '';
        unit.children.forEach(child => {
            // Clone the element to avoid modifying the original
            const clone = child.cloneNode(true);
            
            // Remove all swap link elements from the clone
            const swapLinks = clone.querySelectorAll('.mr-swap-link');
            swapLinks.forEach(link => link.remove());
            
            unitText += clone.innerText + '\n\n'; 
        });
        
        unitText = unitText.trim(); 

        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(unitText)
                .then(() => {
                    showNotification(`Unit ${unitIndex + 1} text copied to clipboard!`, 2000);
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                    showNotification('Failed to copy text. Check console for details.', 3000);
                });
        } else {
            const tempTextarea = document.createElement('textarea');
            tempTextarea.style.position = 'fixed';
            tempTextarea.style.opacity = '0';
            tempTextarea.value = unitText;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            try {
                document.execCommand('copy');
                showNotification(`Unit ${unitIndex + 1} text copied to clipboard! (Fallback)`, 2000);
            } catch (err) {
                console.error('Fallback copy failed: ', err);
                showNotification('Failed to copy text. Your browser does not support automatic copying.', 3000);
            }
            document.body.removeChild(tempTextarea);
        }
    }

    function updateUnitJumpButtons(currentUnitIndex) {
        const buttons = unitJumpRow.querySelectorAll('.jump-btn:not(.copy-btn)');
        buttons.forEach((button, index) => {
            if (index === currentUnitIndex) {
                button.classList.add('active');
            } else {
                button.classList.remove('active');
            }
        });
    }

    function getCurrentUnitProgress() {
        const scroll = editor.scrollTop;
        const totalUnits = state.units.length;
        
        let currentUnitIndex = 0;
        let unitProgress = 0;
        let totalProgress = 0;
        
        console.log(`getCurrentUnitProgress: scroll=${scroll}, totalUnits=${totalUnits}, units.length=${state.units.length}`);
        
        if (totalUnits === 0) {
            const maxScroll = editor.scrollHeight - editor.clientHeight;
            if (maxScroll <= 0) {
                totalProgress = 0;
            } else {
                totalProgress = Math.min(1, scroll / maxScroll);
            }
            console.log(`No units detected. Returning fallback with totalUnits=1, totalProgress=${totalProgress}`);
            return { currentUnitIndex: 0, unitProgress: totalProgress, unitWeight: 1, totalProgress: totalProgress, totalUnits: 1 };
        }
        
        if (state.totalScrollableHeight <= 0) {
            return { currentUnitIndex: 0, unitProgress: 0, unitWeight: 0, totalProgress: 0, totalUnits };
        }

        const unitWeight = 1 / totalUnits;

        for (let i = 0; i < totalUnits; i++) {
            const unit = state.units[i];
            
            if (unit.height <= 0) {
                totalProgress += unitWeight;
                continue;
            }

            if (scroll >= unit.endScroll) {
                totalProgress += unitWeight;
                currentUnitIndex = i + 1;
                continue;
            }

            if (scroll >= unit.startScroll && scroll < unit.endScroll) {
                currentUnitIndex = i;
                const scrolledInUnit = scroll - unit.startScroll;
                unitProgress = Math.min(1, Math.max(0, scrolledInUnit / unit.height));
                totalProgress += (unitProgress * unitWeight);
                break;
            }

            if (scroll < unit.startScroll) {
                 currentUnitIndex = i;
                 unitProgress = 0;
                 break;
            }
        }
        
        totalProgress = Math.min(1, totalProgress);
        
        const scrollMax = editor.scrollHeight - editor.clientHeight;
        if (scroll >= scrollMax && scrollMax > 0) {
            currentUnitIndex = totalUnits - 1;
            unitProgress = 1;
            totalProgress = 1;
        }

        return { currentUnitIndex, unitProgress, unitWeight: unitWeight, totalProgress, totalUnits };
    }

    function updateProgressBars(currentUnitIndex, unitProgress) {
        const bars = topProgressContainer.querySelectorAll('.unit-progress-bar-inner');
        
        bars.forEach((bar, index) => {
            if (index < currentUnitIndex) {
                bar.style.width = '100%';
            } else if (index === currentUnitIndex) {
                bar.style.width = `${Math.round(unitProgress * 100)}%`;
            } else {
                bar.style.width = '0%';
            }
        });
    }
    
    function saveToStorage() {
      try {
        localStorage.setItem('editorContent', editor.innerHTML);
        console.log('Saved content to localStorage. Current state.units.length:', state.units.length);
        localStorage.setItem('editorScrollPosition', editor.scrollTop);
        return true;
      } catch (e) {
        console.error('Save error:', e);
        showNotification('Failed to save your work.', 3000);
        return false;
      }
    }

    function loadContent() {
      try {
        const saved = localStorage.getItem('editorContent');
        console.log('loadContent: saved content length:', saved ? saved.length : 0);
        if (saved) {
          editor.innerHTML = saved;
          console.log('Loaded content from storage. editor.children.length:', editor.children.length);
        } else {
          console.log('No saved content, using default.');
        }
      } catch (e) {
        console.error('Load error:', e);
      }
    }
    
    function saveUndoHistory() {
        try {
            localStorage.setItem('editorUndoHistory', JSON.stringify(state.undoHistory));
        } catch (e) {
            console.error('Failed to save undo history:', e);
        }
    }

    function loadUndoHistory() {
        try {
            const savedHistory = localStorage.getItem('editorUndoHistory');
            if (savedHistory) {
                state.undoHistory = JSON.parse(savedHistory);
            }
        } catch (e) {
            console.error('Failed to load undo history:', e);
            state.undoHistory = [];
        }
        updateHistoryButtonText(); 
    }
    
    function restoreScroll() {
      try {
        const scrollPosition = localStorage.getItem('editorScrollPosition');
        console.log('restoreScroll called. scrollPosition from storage:', scrollPosition);
        if (scrollPosition !== null && scrollPosition !== undefined) {
          const scrollValue = parseInt(scrollPosition, 10);
          if (!isNaN(scrollValue)) {
            console.log('Setting editor.scrollTop to:', scrollValue);
            editor.scrollTop = scrollValue;
            
            requestAnimationFrame(() => {
              console.log('After setting, editor.scrollTop is now:', editor.scrollTop);
              updateStatus();
            });
          }
        } else {
          console.log('No scroll position in localStorage');
        }
      } catch (e) {
        console.error('Scroll restore error:', e);
      }
    }
    
    function saveState() {
      saveToStorage();
      saveUndoHistory();
    }
    
    function toggleTheme() {
      state.isDarkMode = !state.isDarkMode;
      document.body.classList.toggle('dark-mode', state.isDarkMode);
      themeToggle.textContent = state.isDarkMode ? 'â˜€ï¸' : 'ðŸŒ™';
      localStorage.setItem('editorTheme', state.isDarkMode ? 'dark' : 'light');
    }
    
    function clearAllStorage() {
      const confirmed = confirm('Are you sure you want to delete ALL saved data? This cannot be undone.');
      if (confirmed) {
        localStorage.clear();
        state.undoHistory = [];
        editor.innerHTML = '<p>Cleared. Ready for new content.</p>';
        state.wordCount = 0;
        showNotification('All local storage cleared!', 2000);
        setTimeout(() => {
          location.reload();
        }, 1000);
      }
    }
    
    function loadTheme() {
      const savedTheme = localStorage.getItem('editorTheme');
      if (savedTheme === 'dark') {
        state.isDarkMode = true;
        document.body.classList.add('dark-mode');
        themeToggle.textContent = 'â˜€ï¸';
      }
    }
    
    function showNotification(message, duration = config.notificationDuration) {
      notification.textContent = message;
      notification.style.display = 'block';
      notification.style.opacity = '1';
      
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          notification.style.display = 'none';
        }, 300);
      }, duration);
    }
    
    document.addEventListener('DOMContentLoaded', init);
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      init();
    }


  </script>
</body>
</html>
